# Ch5 — Graph

Tree + visited + cycles. Same DFS/BFS, more constraints.

## When to think graph

- Nodes and edges; dependencies; connected components; shortest path (unweighted)
- (Signals to fill)

## Visited and cycles

- When to mark visited (before push vs when pop)
- Directed vs undirected; cycle detection
- (To fill)

## Connected components

- DFS per unvisited node; count or collect
- (To fill)

## BFS shortest path (unweighted)

- Level = distance; first time seen = shortest
- (Template to fill)

## Union-Find — when to use

- Many merge/connected queries; dynamic connectivity
- (To fill)

## Topological sort

- When: "order", "dependency", DAG
- (Template to fill)

## Weighted shortest path (Dijkstra)

- When: weighted edges; need shortest path
- (One line / template to fill)

## Negative weights (Bellman-Ford)

- When: negative edge weights allowed; relax all edges V-1 times
- (One line to fill)

## Minimum Spanning Tree (MST)

- When: "min cost to connect all nodes"; undirected, weighted
- Kruskal: sort edges, Union-Find; Prim: heap, like Dijkstra; (template to fill)

## Bipartite

- When: "can we 2-color"; no odd cycle; BFS/DFS with color
- (Template to fill)

## Strongly Connected Components (SCC)

- When: directed graph; "SCC", "condensed graph"; Tarjan or Kosaraju
- (One line to fill)

## Failure modes

- (To fill)
