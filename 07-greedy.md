# Ch7 — 贪心 (Greedy)

贪心没有统一模板，考的是**「局部最优能推出全局最优」的论证能力**。面试官常问：为什么这样选是对的？你能举反例吗？

---

## 识别信号 (Recognition Signals)

| 题目信号 | 想到的方法 |
|----------|------------|
| 「最多/最少选几个」「能否」「最小代价」 | 先想贪心；若局部≠全局则 DP |
| 「区间」「不重叠」「合并」「覆盖」 | 排序（按 start/end）+ 贪心选 |
| 「调度」「截止时间」「时长」 | 按 deadline 或 (duration, deadline) 排序后贪心 |
| 「字典序最小/最大」 | 从左往右，在满足约束下尽量选小/大 |
| 「跳跃」「能否到达」「最少跳数」 | 贪心维护「当前能到的最远」 |
| 直觉「每一步选当前最好的」可能对 | 试写贪心，再证或造反例 |

---

## 什么时候想到贪心

- **最优子结构** — 大问题的最优解包含小问题的最优解（和 DP 一样），但**贪心多一步**：当前步骤的「局部最优」选择，可以推出全局最优（即不需要像 DP 那样枚举所有子问题）。
- **常见题型** — **区间 (intervals)**：选最多不重叠区间、合并区间、用最少的点覆盖区间等。**调度**：按截止时间或时长排序后贪心。**字典序**：从左往右能小则小。**跳跃**：能否到达、最少跳数等。

**信号：** 问「最多/最少选几个」「能否」「最小代价」且**直觉上「每一步选当前最好的」**可能对时，先想贪心；若举不出反例再写。

---

## 手写模板 (Whiteboard Templates)

**贪心无统一模板，常见结构：**
```
排序：按某一维（start/end/length/deadline）
扫描：for 每个元素：
  若满足「选」的条件（如不重叠、未过期）→ 选，更新状态
  否则跳过
返回：选的个数 / 最后状态
```
**区间选最多不重叠：** 按 **end** 排序，从左到右能选就选（当前 start>= 上一 end）。  
**区间合并：** 按 **start** 排序，能并则并（当前 start<=cur_end 则更新 cur_end）。  
**跳跃：** 维护 max_reach，若 i>max_reach 则 False；否则 max_reach=max(max_reach, i+nums[i])。

---

## 排序策略 (sort strategy)

很多贪心题先**排序**，再一遍扫描做选择。

- **按起点排序** — 区间选最多不重叠：按 end 排序，从左到右能选就选（选当前 end 最小的，给后面留空间）。
- **按终点排序** — 区间合并：按 start 排序，能并则并。
- **按某种权重排序** — 调度题按 deadline 或 (duration, deadline) 等；背包的「性价比」等。
- **字典序** — 从左往右，在满足约束下尽量选小的字符或数字。

```python
# 例：最多不重叠区间（按 end 排序，能选就选）
def max_non_overlapping(intervals):
    if not intervals: return 0
    intervals.sort(key=lambda x: x[1])
    count = 1
    end = intervals[0][1]
    for i in range(1, len(intervals)):
        if intervals[i][0] >= end:
            count += 1
            end = intervals[i][1]
    return count
```

---

## 贪心安全性 (greedy safety)

要能说清楚：**为什么不能通过改变某一步的选择而更好？**

- **交换论证** — 假设存在一个最优解和贪心解在某步不同；把最优解里那一步「换成」贪心选的那个，证明不会变差（或会变好），从而矛盾。
- **归纳** — 第一步选贪心选择后，剩下的是规模更小的同构问题；归纳假设贪心对子问题最优，加上第一步不劣，得整体最优。

---

## 反例思维 (counterexample thinking)

若不确定贪心对不对，**试着造反例**：有没有一种输入，让「当前贪心策略」得到的结果不是最优？

- 例如：区间问题若按 start 排序贪心选「能选就选」，可能错；按 end 排序才对。
- 例如：背包若按「价值/重量」贪心，一般错（需 DP）；但某些特殊约束下可能对。

---

## 复杂度直觉 (Complexity Instincts)

| 类型 | 时间 | 空间 | 一眼看出 |
|------|------|------|----------|
| 排序+扫描 | O(n log n) | O(1) 或 O(n) 排序 | 排序主导 |
| 不排序贪心（如跳跃） | O(n) | O(1) | 扫一遍 |

---

## 例题 (LeetCode)

- **LC 56 合并区间 (Merge Intervals)** — 场景：重叠的区间合并成不重叠的。为何用：区间按起点排序后，能并则并。如何用：按 start 排序，维护当前区间 [cur_start, cur_end]，若下一段 start<=cur_end 则合并（更新 cur_end），否则输出当前区间并开新段。
- **LC 435 无重叠区间 (Non-overlapping Intervals)** — 场景：删最少的区间使剩余区间两两不重叠。为何用：等价于「选最多不重叠区间」= 按 end 排序贪心选。如何用：按 end 排序，从左到右能选就选（当前 start>= 上一 end 则选），计数即最多保留数，n-计数即最少删除数。
- **LC 55 跳跃游戏 (Jump Game)** — 场景：数组表示每步最远跳几格，问能否到最后一格。为何用：贪心维护「当前能到的最远位置」。如何用：遍历 i，若 i>max_reach 则 return False；否则 max_reach=max(max_reach, i+nums[i])；最后看 max_reach>=n-1。

---

## 失败模式 (Failure Modes)

**原内容：**

- **贪心错了却当对的用** — 局部最优不一定全局最优；证不了就考虑 DP 或暴力。
- **排序关键字错** — 区间题按 start 还是 end、按哪个维度排序，要推清楚。
- **边界** — 空列表、单个区间、全部重叠等要单独处理。

**补充：**

- **常见误解** — 「贪心一定 O(n)」：很多要先排序 O(n log n)；「区间都按 start 排序」：选最多不重叠要按 **end** 排序。
- **面试易挂点** — 区间题按错维度（按 start 选最多不重叠会错）；跳跃题漏判 i>max_reach；无法证明时仍坚持贪心而不用 DP。
- **典型反例** — 区间 [[1,3],[2,4],[3,5]] 按 start 选：选 [1,3] 后 [2,4] 不选、[3,5] 选，得 2；按 end 选：选 [1,3]、[3,5] 也得 2；但若 [[1,4],[2,3],[3,4]]，按 start 选得 1，按 end 选得 2，故「选最多不重叠」必须按 end。

---

## 跨章节联系 (Cross-Chapter Links)

- **Ch0 分治** — 分治有合并步骤；贪心无合并，一步选完。
- **Ch6 DP** — 贪心 = 局部最优即全局；DP = 枚举子问题再合并。证不了贪心就用 DP（如零钱兑换）。
- **Ch2 Backtracking** — 回溯枚举所有解；贪心只走一条路，不回溯。
- **Ch4 数据结构** — 某些贪心用堆（如合并 K 个有序链表、Huffman）。
