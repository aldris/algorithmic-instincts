# Ch6 — 动态规划 (Dynamic Programming, DP)

好的 DP = **递归 + 记忆化**。不是新算法，而是「递归重复算了很多次，把结果存起来」的优化。递归不熟，DP 容易写错。

---

## 什么时候想到 DP

- **最优（min/max）或计数** — 「最少步数」「最大和」「有多少种方式」等。
- **重叠子问题 (overlapping subproblems)** — 同一个子问题会被多次用到（递归树里重复出现）。若子问题不重叠，用分治即可，不必 DP。
- **最优子结构 (optimal substructure)** — 大问题的最优解由小问题的最优解得到（如最短路径 = 前一步最短 + 当前边）。

**信号：** 选/不选、第 i 步依赖第 i-1 步、两个序列/区间等。

---

## 状态定义 (state definition)

先想清楚 **dp[i] 或 dp[i][j] 表示什么**。

- **1D** — dp[i] = 以位置 i 结尾（或前 i 个）的某种最优/计数。例如：以 i 结尾的最大和、前 i 个物品的某种值。
- **2D** — dp[i][j] = 两个维度（两个序列的下标、区间 [i,j]、第一个序列前 i 个 + 第二个前 j 个等）。
- **树形 DP** — dp[node] = 以 node 为根的子树上的某种值；合并时用左右子树的 dp 值。

---

## 先写自上而下 (top-down)

先写**递归**：基准情况 + 递推关系。再加上 **memo**（用字典或数组存已算过的 (i, j)），避免重复计算。这样思路清晰，再根据需要改成自下而上。

```python
# 例：爬楼梯，每次 1 或 2 步，到 n 有多少种方式
def climb_stairs(n):
    memo = {}
    def f(i):
        if i <= 1: return 1
        if i in memo: return memo[i]
        memo[i] = f(i-1) + f(i-2)
        return memo[i]
    return f(n)
```

---

## 再写自下而上 / 递推 (bottom-up)

按**依赖顺序**填表：算 dp[i] 时，用到的 dp[i-1]、dp[i-2] 等已经算好。有时可以**滚动数组**省空间（如只保留前两格）。

- **何时用递推** — 避免递归栈溢出、要 O(1) 或滚动空间、迭代顺序很清晰时。
- **填表顺序** — 1D 一般从左到右；2D 看依赖（如 dp[i][j] 依赖左边、上边，则从左到右、从上到下）。

```python
# 爬楼梯，递推
def climb_stairs_bottomup(n):
    if n <= 1: return 1
    a, b = 1, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b
```

---

## 1D / 2D / 树形 DP

- **1D** — 单序列：前 i 个、以 i 结尾等。例如：最大子数组和、打家劫舍。
- **2D** — 两序列（LCS、编辑距离）、区间（石子合并）、背包（前 i 个物品、容量 j）。
- **树形 DP** — 在树上做 DFS，每个节点根据子节点的 dp 值算自己的 dp 值。例如：树上的最大路径和、选节点使权和最大且不相邻。

```python
# 例：最大子数组和
def max_subarray(arr):
    dp = arr[0]  # 以当前结尾的最大和
    best = arr[0]
    for i in range(1, len(arr)):
        dp = max(arr[i], dp + arr[i])
        best = max(best, dp)
    return best
```

---

## 例题 (LeetCode)

- **LC 70 爬楼梯 (Climb Stairs)** — 场景：每次 1 或 2 步，到 n 有几种方式。为何用：计数 + 重叠子问题（f(n) 依赖 f(n-1), f(n-2)）= DP。如何用：dp[i]=dp[i-1]+dp[i-2]，base dp[0]=dp[1]=1；可滚动成两变量。
- **LC 53 最大子数组和 (Maximum Subarray)** — 场景：连续子数组和的最大值。为何用：以 i 结尾的最大和只依赖以 i-1 结尾的，重叠子问题 = 1D DP。如何用：dp[i]=max(nums[i], dp[i-1]+nums[i])，取 max(dp)。
- **LC 1143 最长公共子序列 (Longest Common Subsequence)** — 场景：两个字符串的最长公共子序列长度。为何用：两序列 + 最优 = 2D DP。如何用：dp[i][j]= 若 s1[i]==s2[j] 则 1+dp[i-1][j-1]，否则 max(dp[i-1][j], dp[i][j-1])。
- **LC 322 零钱兑换 (Coin Change)** — 场景：用最少的硬币凑出 amount。为何用：最优 + 子问题重叠（凑 amount 依赖凑 amount-coin）= DP。如何用：dp[v]=min(dp[v], 1+dp[v-coin])，dp[0]=0，其余初值 inf。

---

## 失败模式 (failure modes)

- **状态定义不清** — dp[i] 到底表示「以 i 结尾」还是「前 i 个」要统一；转移时下标别错。
- **基准情况漏写** — dp[0]、dp[0][j] 等要初始化对；有时要 dp[0]=0 或 1 根据题意。
- **递推顺序错** — 自下而上时，算 dp[i] 时依赖的必须已经算过；有环依赖就不能用简单递推。
- **和贪心搞混** — 贪心是「局部最优且能推出全局最优」；DP 是「所有子问题都算出来再合并」。若局部最优不一定全局最优，用 DP。
